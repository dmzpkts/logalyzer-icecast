<div>
  <button on:click="runQuery()">Run Query</button>
  <button on:click="toggleQueryEditor()">
    {{#if __showQueryEditor}}Hide{{else}}Show{{/if}} Query Editor
  </button>
  <span>
    Aggregrate Function:
    <select bind:value="aggregateFunction" on:change="set({chartFunction: __aggregateFunctions[aggregateFunction].defaultChartFunction})">
      {{#each __aggregateFunctionsKeys as key}}
        <option value="{{key}}">
          {{__aggregateFunctions[key].name}}
        </option>
      {{/each}}
    </select>
  </span>
  <span>
    Chart Function:
    <select bind:value="chartFunction">
      {{#each __chartFunctionsKeys as key}}
        <option value="{{key}}">
          {{__chartFunctions[key].name}}
        </option>
      {{/each}}
    </select>
  </span>
  <div class="{{__showQueryEditor ? '' : 'hidden'}}">
    <QueryEditor bind:options bind:selectors bind:supportedClasses="__supportedClasses"></QueryEditor>
  </div>
  <hr />

  <h1>Logalyzer Results</h1>
	<div>
    <div class="loader {{__loading ? '' : 'hidden'}}"></div>
		<canvas class="chart-canvas" ref:canvas></canvas>
	</div>
</div>

<script>
  import QueryEditor from './QueryEditor.html';
  import Nymph from 'Nymph';
  import LogEntry from 'LogEntry';

  const chartColors = {
  	red: 'rgb(229,57,53)',
    indigo: 'rgb(57,73,171)',
    teal: 'rgb(0,137,123)',
    yellow: 'rgb(253,216,53)',
    pink: 'rgb(216,27,96)',
    blue: 'rgb(30,136,229)',
    green: 'rgb(67,160,71)',
    amber: 'rgb(255,179,0)',
    purple: 'rgb(142,36,170)',
    lightBlue: 'rgb(3,155,229)',
    lightGreen: 'rgb(124,179,66)',
    orange: 'rgb(251,140,0)',
    deepPurple: 'rgb(94,53,177)',
    cyan: 'rgb(0,172,193)',
    lime: 'rgb(192,202,51)',
    deepOrange: 'rgb(244,81,30)',
    brown: 'rgb(109,76,65)',
  	grey: 'rgb(117,117,117)',
    blueGrey: 'rgb(84,110,122)'
  };

  const extractBy = function(property, unknownIsCalled, appendProperty) {
    return function (entries) {
      const values = {};
      const data = [];

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        let value = entry.get(property);

        if (!value || value === "-") {
          if (values[unknownIsCalled]) {
            values[unknownIsCalled]++;
          } else {
            values[unknownIsCalled] = 1;
          }
        } else {
          if (appendProperty) {
            let valueAppend = entry.get(appendProperty);
            if (!valueAppend) {
              valueAppend = '-';
            }
            value += ' '+valueAppend;
          }
          if (values[value]) {
            values[value]++;
          } else {
            values[value] = 1;
          }
        }
      }

      // Convert every entry to an array.
      for (let k in values) {
        data.push({
          x: k + " (" + values[k] + ")",
          y: values[k]
        });
      }

      data.sort((a, b) => b.y - a.y);

      return data;
    };
  }

  const aggregateFunctions = {
    totalListenersOverTime: {
      name: "Total Listeners Over Time",
      axisLabel: "Listeners",
      defaultChartFunction: "timeSeries",
      func: function (entries) {
    		const timeFormat = 'YYYY-MM-DD HH:mm:ss';

    		function newDateString(timestamp) {
    			return moment(""+timestamp, "X").format(timeFormat);
    		}

        let earliest, latest, deltas = {}, data = [];

        // Go through and save every time someone logs on and off and the
        // earliest/latest delta.
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          const timeOn = Math.floor(entry.get("time"));
          const timeOff = Math.floor(entry.get("timeEnd"));

          if (timeOn < earliest || earliest === undefined) {
            earliest = timeOn;
          }
          if (timeOff > latest || latest === undefined) {
            latest = timeOff;
          }
          if (deltas[timeOn]) {
            deltas[timeOn]++;
          } else {
            deltas[timeOn] = 1;
          }
          if (deltas[timeOff]) {
            deltas[timeOff]--;
          } else {
            deltas[timeOff] = -1;
          }
        }

        // Now comes the hard part. Going through every second from earliest to
        // latest and calculating number of listeners.
        let currentListeners = 0;
        for (let i = earliest; i <= latest; i++) {
          if (deltas[i]) {
            currentListeners += deltas[i];

            data.push({
              x: newDateString(i),
              y: currentListeners
            });
          }
        }

        return data;
      }
    },

    remoteHost: {
      name: "Remote Host (Unique Visitors)",
      axisLabel: "Requests",
      defaultChartFunction: "horizontalBar",
      func: extractBy("remoteHost", "Unknown")
    },

    resources: {
      name: "Requested Resources",
      axisLabel: "Requests",
      defaultChartFunction: "horizontalBar",
      func: extractBy("resource", "Unknown")
    },

    refererByDomain: {
      name: "Referer By Domain",
      axisLabel: "Requests",
      defaultChartFunction: "horizontalBar",
      func: function (entries) {
        const referers = {
          "Direct Request": 0,
          "Unknown": 0
        };
        const refererDomainRegex = /^\w+:\/\/(?:www\.)?([A-Za-z-.]+)/g;
        const data = [];

        // Go through and parse out the domain of the referer.
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          const referer = entry.get("referer");

          if (!referer || referer === "-") {
            referers["Direct Request"]++;
          } else {
            const match = refererDomainRegex.exec(referer);
            if (match !== null && match.length > 1) {
              if (referers[match[1]]) {
                referers[match[1]]++;
              } else {
                referers[match[1]] = 1;
              }
            } else {
              referers["Unknown"]++;
            }
          }
        }

        // Convert every entry to an array.
        for (let k in referers) {
          data.push({
            x: k,
            y: referers[k]
          });
        }

        data.sort((a, b) => b.y - a.y);

        return data;
      }
    },

    allReferers: {
      name: "All Referers",
      axisLabel: "Requests",
      defaultChartFunction: "horizontalBar",
      func: extractBy("referer", "Direct Request")
    },

    browser: {
      name: "Browser",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaBrowserName", "Unknown")
    },

    browserVersion: {
      name: "Browser Version",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaBrowserName", "Unknown", "uaBrowserVersion")
    },

    cpuArchitecture: {
      name: "CPU Architecture",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaCpuArchitecture", "Unknown")
    },

    deviceType: {
      name: "Device Type",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaDeviceType", "Unknown")
    },

    deviceVendor: {
      name: "Device Vendor",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaDeviceVendor", "Unknown")
    },

    deviceModel: {
      name: "Device Model",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaDeviceVendor", "Unknown", "uaDeviceModel")
    },

    engine: {
      name: "Engine",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaEngineName", "Unknown")
    },

    engineVersion: {
      name: "Engine Version",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaEngineName", "Unknown", "uaEngineVersion")
    },

    os: {
      name: "OS",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaOsName", "Unknown")
    },

    osVersion: {
      name: "OS Version",
      axisLabel: "Requests",
      defaultChartFunction: "pie",
      func: extractBy("uaOsName", "Unknown", "uaOsVersion")
    },

    allUserAgents: {
      name: "All User Agents",
      axisLabel: "Requests",
      defaultChartFunction: "horizontalBar",
      func: extractBy("userAgent", "Unknown")
    },

    responseStatusCode: {
      name: "Response Status Code",
      axisLabel: "Requests",
      defaultChartFunction: "horizontalBar",
      func: extractBy("statusCode", "Unknown")
    },
  };

  const chartFunctions = {
    timeSeries: {
      name: "Time Series",
      func: function (label, axisLabel, data, canvas) {
    		const timeFormat = 'YYYY-MM-DD HH:mm:ss';

    		const color = Chart.helpers.color;
    		const config = {
    			type: 'line',
    			data: {
    				labels: [],
    				datasets: [{
    					label: axisLabel,
    					backgroundColor: color(chartColors.indigo).alpha(0.5).rgbString(),
    					borderColor: chartColors.indigo,
    					fill: false,
    					data: data,
    				}]
    			},
    			options: {
            title:{
              display: true,
              text: label
            },
    				scales: {
    					xAxes: [{
    						type: "time",
    						time: {
    							format: timeFormat,
    							// round: 'day'
    							tooltipFormat: 'll HH:mm'
    						},
    						scaleLabel: {
    							display: true,
    							labelString: 'Date / Time'
    						}
    					}, ],
    					yAxes: [{
    						scaleLabel: {
    							display: true,
    							labelString: axisLabel
    						}
    					}]
    				},
          	// pan: {
          	// 	enabled: true,
          	// 	mode: 'x'
          	// },
          	zoom: {
          		enabled: true,
          		// drag: true,
          		mode: 'x'
          	}
    			}
    		};

  			const ctx = canvas.getContext("2d");
  			return {context: ctx, chart: new Chart(ctx, config)};
      }
    },

    bar: {
      name: "Bar Chart",
      func: function (label, axisLabel, data, canvas) {
    		const color = Chart.helpers.color;
    		const config = {
          type: 'bar',
          data: {
    				labels: data.map((v) => v.x),
            datasets: [{
              label: axisLabel,
              backgroundColor: color(chartColors.blue).alpha(0.5).rgbString(),
              borderColor: chartColors.blueGrey,
              borderWidth: 1,
              data: data.map((v) => v.y)
            }]
          },
          options: {
            // Elements options apply to all of the options unless overridden in a dataset
            // In this case, we are setting the border of each horizontal bar to be 2px wide
            elements: {
              rectangle: {
                borderWidth: 2,
              }
            },
            responsive: true,
            legend: {
              display: false,
            },
            title: {
              display: true,
              text: label
            },
          	pan: {
          		enabled: true,
          		mode: 'xy'
          	},
          	zoom: {
          		enabled: true,
          		drag: true,
          		mode: 'xy'
          	}
          }
        };

  			const ctx = canvas.getContext("2d");
  			return {context: ctx, chart: new Chart(ctx, config)};
      }
    },

    horizontalBar: {
      name: "Horizontal Bar Chart",
      func: function (label, axisLabel, data, canvas) {
    		const color = Chart.helpers.color;
    		const config = {
          type: 'horizontalBar',
          data: {
    				labels: data.map((v) => v.x),
            datasets: [{
              label: axisLabel,
              backgroundColor: color(chartColors.blue).alpha(0.5).rgbString(),
              borderColor: chartColors.blueGrey,
              borderWidth: 1,
              data: data.map((v) => v.y)
            }]
          },
          options: {
            // Elements options apply to all of the options unless overridden in a dataset
            // In this case, we are setting the border of each horizontal bar to be 2px wide
            elements: {
              rectangle: {
                borderWidth: 2,
              }
            },
            responsive: true,
            legend: {
              display: false,
            },
            title: {
              display: true,
              text: label
            },
          	pan: {
          		enabled: true,
          		mode: 'xy'
          	},
          	zoom: {
          		enabled: true,
          		drag: true,
          		mode: 'xy'
          	}
          }
        };

  			const ctx = canvas.getContext("2d");
  			return {context: ctx, chart: new Chart(ctx, config)};
      }
    },

    pie: {
      name: "Pie Chart",
      func: function (label, axisLabel, data, canvas) {
    		const color = Chart.helpers.color;
        const chartColorsKeys = Object.keys(chartColors);
    		const config = {
          type: 'pie',
          data: {
    				labels: data.map((v) => v.x),
            datasets: [{
              label: axisLabel,
              backgroundColor: data.map((v, i) => color(chartColors[chartColorsKeys[i % chartColorsKeys.length]]).alpha(0.5).rgbString()),
              data: data.map((v) => v.y)
            }]
          },
          options: {
            responsive: true,
            title: {
              display: true,
              text: label
            }
          }
        };

  			const ctx = canvas.getContext("2d");
  			return {context: ctx, chart: new Chart(ctx, config)};
      }
    }
  };

  export default {
    data () {
      return {
        __supportedClasses: [LogEntry],
        __showQueryEditor: false,
        __loading: false,
        __currentChart: null,
        __aggregateFunctions: aggregateFunctions,
        __chartFunctions: chartFunctions,
        __aggregateFunctionsKeys: Object.keys(aggregateFunctions),
        __chartFunctionsKeys: Object.keys(chartFunctions),
        aggregateFunction: "totalListenersOverTime",
        chartFunction: "timeSeries",
        options: {
          'class': LogEntry.class
        },
        selectors: [
          {
            'type': '|',
            'strict': [
              ['resource', '/stream'],
              ['resource', '/stream2']
            ]
          },
          {
            "type": "&",
            "gte": [
              ["timeEnd", 1504677600]
            ],
            "lte": [
              ["timeStart", 1504688400]
            ]
          }
        ]
      }
    },

    computed: {
      query: (options, selectors) => [options, ...selectors],
    },

    methods: {
      runQuery () {
        const __currentChart = this.get("__currentChart");
        const aggregateFunction = this.get("aggregateFunction");
        const chartFunction = this.get("chartFunction");

        if (__currentChart) {
          __currentChart.chart.destroy();
          __currentChart.context.clearRect(0, 0, this.refs.canvas.width, this.refs.canvas.height);
        }

        this.set({__loading: true});
        const query = this.get('query');
        Nymph.getEntities(...query).then((entries) => {
          const aggFuncObj = aggregateFunctions[aggregateFunction];
          const chartFuncObj = chartFunctions[chartFunction];
          // Run the aggregator:
          const data = aggFuncObj.func(entries);

          // Create the chart:
          this.set({
            __currentChart: chartFuncObj.func(aggFuncObj.name, aggFuncObj.axisLabel, data, this.refs.canvas),
            __loading: false
          });
        }, (err) => {
          alert("Error: "+err);
        });
      },

      toggleQueryEditor () {
        this.set({__showQueryEditor: !this.get("__showQueryEditor")});
      }
    },

    components: {
      QueryEditor
    }
  };
</script>

<style>
  .hidden {
    display: none;
  }
	.chart-canvas {
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}
  .loader,
  .loader:after {
    border-radius: 50%;
    width: 3em;
    height: 3em;
  }
  .loader {
    margin: 60px auto;
    font-size: 10px;
    position: relative;
    text-indent: -9999em;
    border-top: 1.1em solid rgba(0,0,0, 0.2);
    border-right: 1.1em solid rgba(0,0,0, 0.2);
    border-bottom: 1.1em solid rgba(0,0,0, 0.2);
    border-left: 1.1em solid #000000;
    -webkit-transform: translateZ(0);
    -ms-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-animation: load8 1.1s infinite linear;
    animation: load8 1.1s infinite linear;
  }
  @-webkit-keyframes load8 {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  @keyframes load8 {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
</style>
