/* src/ValueEditor.html generated by Svelte v1.41.0 */
var ValueEditor = (function() { "use strict";

	// const moment = moment || require("moment");
const strtotime = window.strtotime || require("locutus/php/datetime/strtotime");

function valueType(value, valueTypeCurrent, allowedTypes) {
  if (allowedTypes.length === 1) {
    return allowedTypes[0] === "date" ? "float" : allowedTypes[0];
  }
  switch (typeof value) {
    case "number":
      if (valueTypeCurrent === "date") {
        return "float";
      }
      if (value % 1 > 0) {
        return valueTypeCurrent || "float";
      } else {
        return valueTypeCurrent || "int";
      }
    case "boolean":
      return "boolean";
    case "string":
    default:
      return "string";
  }
}

	function data() {
  return {
    __showDatePrompt: false,
    __dateInput: "",
    __dateInputTimestamp: 0,
    __dateInputInterpretation: "",
    valueTypeInitial: null,
    valueTypeCurrent: null,
    allowedTypes: ["string", "int", "float", "boolean", "date"],
    value: ""
  }
};

	var methods = {
  changeValueType () {
    const valueTypeCurrent = this.get("valueTypeCurrent");
    let value = this.get("value");

    switch (valueTypeCurrent) {
      case "string":
        value = ""+value;
        break;
      case "int":
        value = parseInt(value, 10);
        break;
      case "float":
        value = parseFloat(value, 10);
        break;
      case "boolean":
        value = !!value;
        break;
      case "date":
        this.openDatePrompt();
        return;
    }

    this.set({value});
  },

  handleDateInput () {
    const __dateInput = this.get("__dateInput");
    const __dateInputTimestamp = this.interpretDate(__dateInput);
    const __dateInputInterpretation = __dateInputTimestamp ? this.formatDate(__dateInputTimestamp) : "Unrecognized";

    this.set({
      __dateInputTimestamp,
      __dateInputInterpretation
    });
  },

  interpretDate (input) {
    return strtotime(""+input, Math.floor(Date.now() / 1000));
  },

  formatDate (timestamp) {
    return new Date(timestamp * 1000).toLocaleString(undefined, {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    });
  },

  makeInt () {
    this.set({value: parseInt(this.get("value"), 10)});
  },

  openDatePrompt () {
    let value = parseInt(this.get("value"), 10);
    if (!value) {
      value = parseInt(Math.floor(Date.now() / 1000));
    }
    this.set({
      __showDatePrompt: true,
      __dateInput: new Date(value * 1000).toString(),
      value: value
    });
    this.handleDateInput();
  },

  acceptDatePrompt () {
    const value = this.get("__dateInputTimestamp");
    this.set({value});
    this.closeDatePrompt();
  },

  closeDatePrompt () {
    this.set({
      __showDatePrompt: false,
      __dateInput: "",
      __dateInputTimestamp: 0,
      __dateInputInterpretation: ""
    });
  }
};

	function oncreate() {
  const valueTypeInitial = this.get("valueTypeInitial");
  this.set({valueTypeCurrent: valueTypeInitial === null ? this.get("valueType") : valueTypeInitial});

  if (!strtotime) {
    throw new Error("ValueEditor requires Locutus' strtotime for date interpretation.");
  }
};

	function encapsulateStyles(node) {
		setAttribute(node, "svelte-202135697", "");
	}

	function add_css() {
		var style = createElement("style");
		style.id = 'svelte-202135697-style';
		style.textContent = "[svelte-202135697].date-prompt-container,[svelte-202135697] .date-prompt-container{display:flex;justify-content:center;align-items:center;position:fixed;top:0;left:0;bottom:0;right:0;background-color:rgba(0, 0, 0, 0.3)}[svelte-202135697].date-prompt,[svelte-202135697] .date-prompt{display:flex;flex-direction:column;box-shadow:0px 5px 36px 0px rgba(0,0,0,0.25);background-color:#fff;padding:2em;max-height:80vh;max-width:80vw;overflow:auto}[svelte-202135697].date-prompt > *,[svelte-202135697] .date-prompt > *{margin-bottom:1em}[svelte-202135697].date-prompt > *:last-child,[svelte-202135697] .date-prompt > *:last-child{margin-bottom:0}[svelte-202135697].date-prompt .date-interpretation,[svelte-202135697] .date-prompt .date-interpretation{border:1px solid;padding:.2em}[svelte-202135697].date-prompt .actions,[svelte-202135697] .date-prompt .actions{display:flex;flex-direction:row;justify-content:flex-end;align-items:center}[svelte-202135697].date-prompt .actions > *,[svelte-202135697] .date-prompt .actions > *{margin-left:1em}";
		appendNode(style, document.head);
	}

	function create_main_fragment(state, component) {
		var span, text, text_1;

		var if_block = (state.allowedTypes.length > 1) && create_if_block(state, component);

		var current_block_type = select_block_type_1(state);
		var if_block_1 = current_block_type && current_block_type(state, component);

		var if_block_5 = (state.__showDatePrompt) && create_if_block_13(state, component);

		return {
			c: function create() {
				span = createElement("span");
				if (if_block) if_block.c();
				text = createText("\n  ");
				if (if_block_1) if_block_1.c();
				text_1 = createText("\n  ");
				if (if_block_5) if_block_5.c();
				this.h();
			},

			h: function hydrate() {
				encapsulateStyles(span);
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				if (if_block) if_block.m(span, null);
				appendNode(text, span);
				if (if_block_1) if_block_1.m(span, null);
				appendNode(text_1, span);
				if (if_block_5) if_block_5.m(span, null);
			},

			p: function update(changed, state) {
				if (state.allowedTypes.length > 1) {
					if (if_block) {
						if_block.p(changed, state);
					} else {
						if_block = create_if_block(state, component);
						if_block.c();
						if_block.m(span, text);
					}
				} else if (if_block) {
					if_block.u();
					if_block.d();
					if_block = null;
				}

				if (current_block_type === (current_block_type = select_block_type_1(state)) && if_block_1) {
					if_block_1.p(changed, state);
				} else {
					if (if_block_1) {
						if_block_1.u();
						if_block_1.d();
					}
					if_block_1 = current_block_type && current_block_type(state, component);
					if (if_block_1) if_block_1.c();
					if (if_block_1) if_block_1.m(span, text_1);
				}

				if (state.__showDatePrompt) {
					if (if_block_5) {
						if_block_5.p(changed, state);
					} else {
						if_block_5 = create_if_block_13(state, component);
						if_block_5.c();
						if_block_5.m(span, null);
					}
				} else if (if_block_5) {
					if_block_5.u();
					if_block_5.d();
					if_block_5 = null;
				}
			},

			u: function unmount() {
				detachNode(span);
				if (if_block) if_block.u();
				if (if_block_1) if_block_1.u();
				if (if_block_5) if_block_5.u();
			},

			d: function destroy() {
				if (if_block) if_block.d();
				if (if_block_1) if_block_1.d();
				if (if_block_5) if_block_5.d();
			}
		};
	}

	// (4:6) {{#if allowedTypes.indexOf("string") > -1}}
	function create_if_block_1(state, component) {
		var option;

		return {
			c: function create() {
				option = createElement("option");
				option.textContent = "String";
				this.h();
			},

			h: function hydrate() {
				option.__value = "string";
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (9:6) {{#if allowedTypes.indexOf("int") > -1}}
	function create_if_block_2(state, component) {
		var option;

		return {
			c: function create() {
				option = createElement("option");
				option.textContent = "Integer";
				this.h();
			},

			h: function hydrate() {
				option.__value = "int";
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (14:6) {{#if allowedTypes.indexOf("float") > -1}}
	function create_if_block_3(state, component) {
		var option;

		return {
			c: function create() {
				option = createElement("option");
				option.textContent = "Float";
				this.h();
			},

			h: function hydrate() {
				option.__value = "float";
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (19:6) {{#if allowedTypes.indexOf("boolean") > -1}}
	function create_if_block_4(state, component) {
		var option;

		return {
			c: function create() {
				option = createElement("option");
				option.textContent = "Boolean";
				this.h();
			},

			h: function hydrate() {
				option.__value = "boolean";
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (24:6) {{#if allowedTypes.indexOf("date") > -1}}
	function create_if_block_5(state, component) {
		var option;

		return {
			c: function create() {
				option = createElement("option");
				option.textContent = "Date (Unix Timestamp)";
				this.h();
			},

			h: function hydrate() {
				option.__value = "date";
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (29:13) {{#if valueTypeCurrent === "date"}}
	function create_if_block_6(state, component) {
		var button;

		function click_handler(event) {
			component.openDatePrompt();
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "Open Date Prompt";
				this.h();
			},

			h: function hydrate() {
				addListener(button, "click", click_handler);
			},

			m: function mount(target, anchor) {
				insertNode(button, target, anchor);
			},

			u: function unmount() {
				detachNode(button);
			},

			d: function destroy() {
				removeListener(button, "click", click_handler);
			}
		};
	}

	// (2:2) {{#if allowedTypes.length > 1}}
	function create_if_block(state, component) {
		var text, select, if_block_anchor, if_block_1_anchor, if_block_2_anchor, if_block_3_anchor, select_updating = false, text_1;

		var if_block = (state.allowedTypes.indexOf("string") > -1) && create_if_block_1(state, component);

		var if_block_1 = (state.allowedTypes.indexOf("int") > -1) && create_if_block_2(state, component);

		var if_block_2 = (state.allowedTypes.indexOf("float") > -1) && create_if_block_3(state, component);

		var if_block_3 = (state.allowedTypes.indexOf("boolean") > -1) && create_if_block_4(state, component);

		var if_block_4 = (state.allowedTypes.indexOf("date") > -1) && create_if_block_5(state, component);

		function select_change_handler() {
			select_updating = true;
			var selectedOption = select.querySelector(':checked') || select.options[0];
			component.set({ valueTypeCurrent: selectedOption && selectedOption.__value });
			select_updating = false;
		}

		function change_handler(event) {
			component.changeValueType();
		}

		var if_block_5 = (state.valueTypeCurrent === "date") && create_if_block_6(state, component);

		return {
			c: function create() {
				text = createText("(Type: ");
				select = createElement("select");
				if (if_block) if_block.c();
				if_block_anchor = createComment();
				if (if_block_1) if_block_1.c();
				if_block_1_anchor = createComment();
				if (if_block_2) if_block_2.c();
				if_block_2_anchor = createComment();
				if (if_block_3) if_block_3.c();
				if_block_3_anchor = createComment();
				if (if_block_4) if_block_4.c();
				if (if_block_5) if_block_5.c();
				text_1 = createText(")\n    Value:");
				this.h();
			},

			h: function hydrate() {
				if (!('valueTypeCurrent' in state)) component._root._beforecreate.push(select_change_handler);

				addListener(select, "change", select_change_handler);
				addListener(select, "change", change_handler);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
				insertNode(select, target, anchor);
				if (if_block) if_block.m(select, null);
				appendNode(if_block_anchor, select);
				if (if_block_1) if_block_1.m(select, null);
				appendNode(if_block_1_anchor, select);
				if (if_block_2) if_block_2.m(select, null);
				appendNode(if_block_2_anchor, select);
				if (if_block_3) if_block_3.m(select, null);
				appendNode(if_block_3_anchor, select);
				if (if_block_4) if_block_4.m(select, null);

				var value = state.valueTypeCurrent;
				for (var i = 0; i < select.options.length; i += 1) {
					var option = select.options[i];

					if (option.__value === value) {
						option.selected = true;
						break;
					}
				}

				if (if_block_5) if_block_5.m(target, anchor);
				insertNode(text_1, target, anchor);
			},

			p: function update(changed, state) {
				if (state.allowedTypes.indexOf("string") > -1) {
					if (!if_block) {
						if_block = create_if_block_1(state, component);
						if_block.c();
						if_block.m(select, if_block_anchor);
					}
				} else if (if_block) {
					if_block.u();
					if_block.d();
					if_block = null;
				}

				if (state.allowedTypes.indexOf("int") > -1) {
					if (!if_block_1) {
						if_block_1 = create_if_block_2(state, component);
						if_block_1.c();
						if_block_1.m(select, if_block_1_anchor);
					}
				} else if (if_block_1) {
					if_block_1.u();
					if_block_1.d();
					if_block_1 = null;
				}

				if (state.allowedTypes.indexOf("float") > -1) {
					if (!if_block_2) {
						if_block_2 = create_if_block_3(state, component);
						if_block_2.c();
						if_block_2.m(select, if_block_2_anchor);
					}
				} else if (if_block_2) {
					if_block_2.u();
					if_block_2.d();
					if_block_2 = null;
				}

				if (state.allowedTypes.indexOf("boolean") > -1) {
					if (!if_block_3) {
						if_block_3 = create_if_block_4(state, component);
						if_block_3.c();
						if_block_3.m(select, if_block_3_anchor);
					}
				} else if (if_block_3) {
					if_block_3.u();
					if_block_3.d();
					if_block_3 = null;
				}

				if (state.allowedTypes.indexOf("date") > -1) {
					if (!if_block_4) {
						if_block_4 = create_if_block_5(state, component);
						if_block_4.c();
						if_block_4.m(select, null);
					}
				} else if (if_block_4) {
					if_block_4.u();
					if_block_4.d();
					if_block_4 = null;
				}

				if (!select_updating) {
					var value = state.valueTypeCurrent;
					for (var i = 0; i < select.options.length; i += 1) {
						var option = select.options[i];

						if (option.__value === value) {
							option.selected = true;
							break;
						}
					}
				}

				if (state.valueTypeCurrent === "date") {
					if (!if_block_5) {
						if_block_5 = create_if_block_6(state, component);
						if_block_5.c();
						if_block_5.m(text_1.parentNode, text_1);
					}
				} else if (if_block_5) {
					if_block_5.u();
					if_block_5.d();
					if_block_5 = null;
				}
			},

			u: function unmount() {
				detachNode(text);
				detachNode(select);
				if (if_block) if_block.u();
				if (if_block_1) if_block_1.u();
				if (if_block_2) if_block_2.u();
				if (if_block_3) if_block_3.u();
				if (if_block_4) if_block_4.u();
				if (if_block_5) if_block_5.u();
				detachNode(text_1);
			},

			d: function destroy() {
				if (if_block) if_block.d();
				if (if_block_1) if_block_1.d();
				if (if_block_2) if_block_2.d();
				if (if_block_3) if_block_3.d();
				if (if_block_4) if_block_4.d();
				removeListener(select, "change", select_change_handler);
				removeListener(select, "change", change_handler);
				if (if_block_5) if_block_5.d();
			}
		};
	}

	// (39:59) {{#if value}}
	function create_if_block_11(state, component) {
		var text;

		return {
			c: function create() {
				text = createText("True");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	// (39:76) {{else}}
	function create_if_block_12(state, component) {
		var text;

		return {
			c: function create() {
				text = createText("False");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	// (32:2) {{#if valueType === "string"}}
	function create_if_block_7(state, component) {
		var input, input_updating = false;

		function input_input_handler() {
			input_updating = true;
			component.set({ value: input.value });
			input_updating = false;
		}

		return {
			c: function create() {
				input = createElement("input");
				this.h();
			},

			h: function hydrate() {
				input.type = "text";
				addListener(input, "input", input_input_handler);
			},

			m: function mount(target, anchor) {
				insertNode(input, target, anchor);

				input.value = state.value;
			},

			p: function update(changed, state) {
				if (!input_updating) {
					input.value = state.value;
				}
			},

			u: function unmount() {
				detachNode(input);
			},

			d: function destroy() {
				removeListener(input, "input", input_input_handler);
			}
		};
	}

	// (34:32) 
	function create_if_block_8(state, component) {
		var input, input_updating = false;

		function input_input_handler() {
			input_updating = true;
			component.set({ value: toNumber(input.value) });
			input_updating = false;
		}

		function input_handler(event) {
			component.makeInt();
		}

		return {
			c: function create() {
				input = createElement("input");
				this.h();
			},

			h: function hydrate() {
				input.type = "number";
				addListener(input, "input", input_input_handler);
				addListener(input, "input", input_handler);
			},

			m: function mount(target, anchor) {
				insertNode(input, target, anchor);

				input.value = state.value;
			},

			p: function update(changed, state) {
				if (!input_updating) {
					input.value = state.value;
				}
			},

			u: function unmount() {
				detachNode(input);
			},

			d: function destroy() {
				removeListener(input, "input", input_input_handler);
				removeListener(input, "input", input_handler);
			}
		};
	}

	// (36:34) 
	function create_if_block_9(state, component) {
		var input, input_updating = false;

		function input_input_handler() {
			input_updating = true;
			component.set({ value: toNumber(input.value) });
			input_updating = false;
		}

		return {
			c: function create() {
				input = createElement("input");
				this.h();
			},

			h: function hydrate() {
				input.type = "number";
				addListener(input, "input", input_input_handler);
			},

			m: function mount(target, anchor) {
				insertNode(input, target, anchor);

				input.value = state.value;
			},

			p: function update(changed, state) {
				if (!input_updating) {
					input.value = state.value;
				}
			},

			u: function unmount() {
				detachNode(input);
			},

			d: function destroy() {
				removeListener(input, "input", input_input_handler);
			}
		};
	}

	// (38:36) 
	function create_if_block_10(state, component) {
		var label, input, text, text_1;

		function input_change_handler() {
			component.set({ value: input.checked });
		}

		var current_block_type = select_block_type(state);
		var if_block = current_block_type(state, component);

		return {
			c: function create() {
				label = createElement("label");
				input = createElement("input");
				text = createText(" (");
				if_block.c();
				text_1 = createText(")");
				this.h();
			},

			h: function hydrate() {
				input.type = "checkbox";
				addListener(input, "change", input_change_handler);
			},

			m: function mount(target, anchor) {
				insertNode(label, target, anchor);
				appendNode(input, label);

				input.checked = state.value;

				appendNode(text, label);
				if_block.m(label, null);
				appendNode(text_1, label);
			},

			p: function update(changed, state) {
				input.checked = state.value;

				if (current_block_type !== (current_block_type = select_block_type(state))) {
					if_block.u();
					if_block.d();
					if_block = current_block_type(state, component);
					if_block.c();
					if_block.m(label, text_1);
				}
			},

			u: function unmount() {
				detachNode(label);
				if_block.u();
			},

			d: function destroy() {
				removeListener(input, "change", input_change_handler);
				if_block.d();
			}
		};
	}

	// (41:2) {{#if __showDatePrompt}}
	function create_if_block_13(state, component) {
		var span, span_1, span_2, text_2, input, input_updating = false, text_3, span_3, text_5, span_4, text_6, text_7, span_5, button, text_9, button_1, button_1_disabled_value;

		function input_input_handler() {
			input_updating = true;
			component.set({ __dateInput: input.value });
			input_updating = false;
		}

		function input_handler(event) {
			component.handleDateInput();
		}

		function click_handler(event) {
			component.closeDatePrompt();
		}

		function click_handler_1(event) {
			component.acceptDatePrompt();
		}

		return {
			c: function create() {
				span = createElement("span");
				span_1 = createElement("span");
				span_2 = createElement("span");
				span_2.innerHTML = "Enter a date below in basically any format, including things like \"now\", \"last friday\",\n          <br>\n          \"+1 week\", and \"oct 12, 2017 3:00 pm\":";
				text_2 = createText("\n\n        ");
				input = createElement("input");
				text_3 = createText("\n\n        ");
				span_3 = createElement("span");
				span_3.textContent = "The current input is being interpreted as:";
				text_5 = createText("\n\n        ");
				span_4 = createElement("span");
				text_6 = createText(state.__dateInputInterpretation);
				text_7 = createText("\n\n        ");
				span_5 = createElement("span");
				button = createElement("button");
				button.textContent = "Cancel";
				text_9 = createText("\n          ");
				button_1 = createElement("button");
				button_1.textContent = "Accept";
				this.h();
			},

			h: function hydrate() {
				span.className = "date-prompt-container";
				span_1.className = "date-prompt";
				input.type = "text";
				addListener(input, "input", input_input_handler);
				addListener(input, "input", input_handler);
				span_4.className = "date-interpretation";
				span_5.className = "actions";
				addListener(button, "click", click_handler);
				button_1.disabled = button_1_disabled_value = state.__dateInputTimestamp === false;
				addListener(button_1, "click", click_handler_1);
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				appendNode(span_1, span);
				appendNode(span_2, span_1);
				appendNode(text_2, span_1);
				appendNode(input, span_1);

				input.value = state.__dateInput;

				appendNode(text_3, span_1);
				appendNode(span_3, span_1);
				appendNode(text_5, span_1);
				appendNode(span_4, span_1);
				appendNode(text_6, span_4);
				appendNode(text_7, span_1);
				appendNode(span_5, span_1);
				appendNode(button, span_5);
				appendNode(text_9, span_5);
				appendNode(button_1, span_5);
			},

			p: function update(changed, state) {
				if (!input_updating) {
					input.value = state.__dateInput;
				}

				if (changed.__dateInputInterpretation) {
					text_6.data = state.__dateInputInterpretation;
				}

				if ((changed.__dateInputTimestamp) && button_1_disabled_value !== (button_1_disabled_value = state.__dateInputTimestamp === false)) {
					button_1.disabled = button_1_disabled_value;
				}
			},

			u: function unmount() {
				detachNode(span);
			},

			d: function destroy() {
				removeListener(input, "input", input_input_handler);
				removeListener(input, "input", input_handler);
				removeListener(button, "click", click_handler);
				removeListener(button_1, "click", click_handler_1);
			}
		};
	}

	function select_block_type(state) {
		if (state.value) return create_if_block_11;
		return create_if_block_12;
	}

	function select_block_type_1(state) {
		if (state.valueType === "string") return create_if_block_7;
		if (state.valueType === "int") return create_if_block_8;
		if (state.valueType === "float") return create_if_block_9;
		if (state.valueType === "boolean") return create_if_block_10;
		return null;
	}

	function ValueEditor(options) {
		init(this, options);
		this._state = assign(data(), options.data);
		this._recompute({ value: 1, valueTypeCurrent: 1, allowedTypes: 1 }, this._state);

		if (!document.getElementById("svelte-202135697-style")) add_css();

		var _oncreate = oncreate.bind(this);

		if (!options._root) {
			this._oncreate = [_oncreate];
			this._beforecreate = [];
		} else {
		 	this._root._oncreate.push(_oncreate);
		 }

		this._fragment = create_main_fragment(this._state, this);

		if (options.target) {
			this._fragment.c();
			this._fragment.m(options.target, options.anchor || null);

			callAll(this._beforecreate);
			callAll(this._oncreate);
		}
	}

	assign(ValueEditor.prototype, methods, {
	 	destroy: destroy,
	 	get: get,
	 	fire: fire,
	 	observe: observe,
	 	on: on,
	 	set: set,
	 	teardown: destroy,
	 	_set: _set,
	 	_mount: _mount,
	 	_unmount: _unmount
	 });

	ValueEditor.prototype._recompute = function _recompute(changed, state) {
		if (changed.value || changed.valueTypeCurrent || changed.allowedTypes) {
			if (differs(state.valueType, (state.valueType = valueType(state.value, state.valueTypeCurrent, state.allowedTypes)))) changed.valueType = true;
		}
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function noop() {}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function createComment() {
		return document.createComment('');
	}

	function toNumber(value) {
		return value === '' ? undefined : +value;
	}

	function init(component, options) {
		component.options = options;

		component._observers = { pre: blankObject(), post: blankObject() };
		component._handlers = blankObject();
		component._root = options._root || component;
		component._yield = options._yield;
		component._bind = options._bind;
	}

	function assign(target) {
		var k,
			source,
			i = 1,
			len = arguments.length;
		for (; i < len; i++) {
			source = arguments[i];
			for (k in source) target[k] = source[k];
		}

		return target;
	}

	function callAll(fns) {
		while (fns && fns.length) fns.pop()();
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = this.get = noop;

		if (detach !== false) this._fragment.u();
		this._fragment.d();
		this._fragment = this._state = null;
	}

	function get(key) {
		return key ? this._state[key] : this._state;
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			handlers[i].call(this, data);
		}
	}

	function observe(key, callback, options) {
		var group = options && options.defer
			? this._observers.post
			: this._observers.pre;

		(group[key] || (group[key] = [])).push(callback);

		if (!options || options.init !== false) {
			callback.__calling = true;
			callback.call(this, this._state[key]);
			callback.__calling = false;
		}

		return {
			cancel: function() {
				var index = group[key].indexOf(callback);
				if (~index) group[key].splice(index, 1);
			}
		};
	}

	function on(eventName, handler) {
		if (eventName === 'teardown') return this.on('destroy', handler);

		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this._root._lock) return;
		this._root._lock = true;
		callAll(this._root._beforecreate);
		callAll(this._root._oncreate);
		callAll(this._root._aftercreate);
		this._root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign({}, oldState, newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);
		dispatchObservers(this, this._observers.pre, changed, this._state, oldState);
		this._fragment.p(changed, this._state);
		dispatchObservers(this, this._observers.post, changed, this._state, oldState);
	}

	function _mount(target, anchor) {
		this._fragment.m(target, anchor);
	}

	function _unmount() {
		this._fragment.u();
	}

	function differs(a, b) {
		return a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function blankObject() {
		return Object.create(null);
	}

	function dispatchObservers(component, group, changed, newState, oldState) {
		for (var key in group) {
			if (!changed[key]) continue;

			var newValue = newState[key];
			var oldValue = oldState[key];

			var callbacks = group[key];
			if (!callbacks) continue;

			for (var i = 0; i < callbacks.length; i += 1) {
				var callback = callbacks[i];
				if (callback.__calling) continue;

				callback.__calling = true;
				callback.call(component, newValue, oldValue);
				callback.__calling = false;
			}
		}
	}
	return ValueEditor;
}());