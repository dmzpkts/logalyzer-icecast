<div>
  <div class="d-flex">
    <label class="mx-3 mb-0">
      Aggregrator
      <select class="form-control d-inline w-auto ml-2" bind:value="aggregateFunction" on:change="set({chartFunction: __aggregateFunctions[aggregateFunction].defaultChartFunction})">
        {{#each __aggregateFunctionsKeys as key}}
          <option value="{{key}}">
            {{__aggregateFunctions[key].name}}
          </option>
        {{/each}}
      </select>
    </label>
    <label class="mx-3 mb-0">
      Chart
      <select class="form-control d-inline w-auto ml-2" bind:value="chartFunction">
        {{#each __chartFunctionsKeys as key}}
          <option value="{{key}}">
            {{__chartFunctions[key].name}}
          </option>
        {{/each}}
      </select>
    </label>
    <button type="button" class="btn btn-secondary mx-3" on:click="toggleQueryEditor()">
      {{#if __showQueryEditor}}Hide{{else}}Show{{/if}} Query Editor
    </button>
    <button type="button" class="btn btn-primary ml-auto" on:click="runQuery()">Run Query</button>
  </div>
  <div class="mb-3 {{__showQueryEditor ? '' : 'd-none'}}">
    <QueryEditor
        bind:options
        bind:selectors
        bind:supportedClasses="__supportedClasses"
        classCheckbox="mr-1"
        classInput="form-control form-control-sm d-inline w-auto"
        classSelect="form-control form-control-sm d-inline w-auto"
        classAddButton="btn btn-sm btn-primary mx-1"
        classRemoveButton="btn btn-sm btn-danger mx-1"
        classButton="btn btn-sm btn-secondary mx-1"></QueryEditor>
  </div>
  <hr />

  <div class="d-flex align-items-start justify-content-between">
    <h4>Results</h4>
    <div>
      <button class="btn btn-secondary" on:click="set({chartHeight: chartHeight+40})">Increase Height</button>
      <button class="btn btn-secondary" on:click="set({chartHeight: chartHeight-40})">Decrease Height</button>
    </div>
  </div>
  <div style="position: relative;">
    <div class="loader {{__loading ? '' : 'd-none'}}"></div>
    <div class="chart-container" ref:canvascontainer style="position: relative; height: {{chartHeight}}px; width: 100%">
        <div class="{{(__currentChart && __currentChart.raw) ? 'card' : 'hidden'}}">
          <div class="card-body">
            <pre class="raw-elem" ref:rawelem></pre>
          </div>
        </div>
        <div class="{{(__currentChart && __currentChart.svg) ? 'chart-svg' : 'hidden'}}">
          <h5 ref:titlesvg class="text-center"></h5>
          <div ref:chartsvg></div>
        </div>
      <canvas class="{{(__currentChart && __currentChart.chart) ? 'chart-canvas' : 'hidden'}}" ref:chartcanvas></canvas>
    </div>
  </div>
</div>

<script>
  import QueryEditor from 'QueryEditor';
  import Nymph from 'Nymph';
  import IceCastAccessLogEntry from 'IceCastAccessLogEntry';

  const chartColors = {
    red: 'rgb(229,57,53)',
    indigo: 'rgb(57,73,171)',
    teal: 'rgb(0,137,123)',
    yellow: 'rgb(253,216,53)',
    pink: 'rgb(216,27,96)',
    blue: 'rgb(30,136,229)',
    green: 'rgb(67,160,71)',
    amber: 'rgb(255,179,0)',
    purple: 'rgb(142,36,170)',
    lightBlue: 'rgb(3,155,229)',
    lightGreen: 'rgb(124,179,66)',
    orange: 'rgb(251,140,0)',
    deepPurple: 'rgb(94,53,177)',
    cyan: 'rgb(0,172,193)',
    lime: 'rgb(192,202,51)',
    deepOrange: 'rgb(244,81,30)',
    brown: 'rgb(109,76,65)',
    grey: 'rgb(117,117,117)',
    blueGrey: 'rgb(84,110,122)'
  };

  ///////////////////////////////////////
  //  Charting Functions
  ///////////////////////////////////////

  const timeSeries = function(graphType, area, stepped) {
    return function (app, label, axisLabel, data, elems, eventHandlers) {
      const timeFormat = 'YYYY-MM-DD HH:mm:ss';

      const color = Chart.helpers.color;
      const config = {
        type: graphType,
        data: {
          labels: [],
          datasets: [{
            label: axisLabel,
            backgroundColor: color(chartColors.indigo).alpha(0.5).rgbString(),
            borderColor: chartColors.indigo,
            fill: !!area,
            steppedLine: !!stepped,
            lineTension: 0,
            // cubicInterpolationMode: 'monotone',
            data: data.map((v) => ({x: v.label, y: v.value}))
          }]
        },
        options: {
          title:{
            display: true,
            text: label
          },
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            xAxes: [{
              type: "time",
              time: {
                format: timeFormat,
                // round: 'day'
                tooltipFormat: 'll HH:mm'
              },
              scaleLabel: {
                display: true,
                labelString: 'Date / Time'
              }
            }, ],
            yAxes: [{
              scaleLabel: {
                display: true,
                labelString: axisLabel
              }
            }]
          },
          onClick: function(ev, elements) {
            if (
                elements[0] !== undefined &&
                elements[0]._model !== undefined &&
                elements[0]._model.label !== undefined &&
                eventHandlers !== undefined &&
                eventHandlers.hasOwnProperty(elements[0]._model.label)
              ) {
              eventHandlers[elements[0]._model.label](app);
            }
          }
        }
      };

      const ctx = elems.canvas.getContext("2d");
      return {context: ctx, chart: new Chart(ctx, config)};
    }
  };

  const c3CategoryChart = function(graphType, rotated) {
    return function (app, label, axisLabel, data, elems, eventHandlers) {
      const config = {
        bindto: elems.svg,
        data: {
          type: graphType,
          json: data.map(v => {v[axisLabel] = v.value; return v;}),
          keys: {
            x: 'label',
            value: [axisLabel]
          },
          onclick: function(d, element) {
            if (
                d.name !== undefined &&
                eventHandlers !== undefined &&
                eventHandlers.hasOwnProperty(d.name)
              ) {
              eventHandlers[d.name](app);
            }
          }
        },
        axis: {
          x: {
            type: 'category'
          },
          rotated: rotated
        },
        size: {
          height: app.get('chartHeight')
        },
        zoom: {
          enabled: true
        }
      };

      elems.titlesvg.innerText = label + " (" + data.length + " total)";

      return {svg: c3.generate(config)};
    };
  };

  const c3Chart = function(graphType, rotated) {
    return function (app, label, axisLabel, data, elems, eventHandlers) {
      const config = {
        bindto: elems.svg,
        data: {
          type: graphType,
          columns: data.map((v) => [v.label, v.value]),
          onclick: function(d, element) {
            if (
                d.name !== undefined &&
                eventHandlers !== undefined &&
                eventHandlers.hasOwnProperty(d.name)
              ) {
              eventHandlers[d.name](app);
            }
          }
        },
        bar: {
          width: {
            ratio: 1
          }
        },
        axis: {
          y: {
            label: {
              text: axisLabel,
              position: 'outer-middle'
            }
          },
          rotated: rotated
        },
        size: {
          height: app.get('chartHeight')
        },
        zoom: {
          enabled: true
        }
      };

      elems.titlesvg.innerText = label + " (" + data.length + " total)";

      return {svg: c3.generate(config)};
    };
  };

  const chartFunctions = {
    timeSeriesSteppedArea: {
      name: "Chart.js - Time Series Stepped Area",
      func: timeSeries("line", true, true)
    },

    timeSeriesStepped: {
      name: "Chart.js - Time Series Stepped",
      func: timeSeries("line", false, true)
    },

    timeSeriesLine: {
      name: "Chart.js - Time Series Line",
      func: timeSeries("line")
    },

    timeSeriesArea: {
      name: "Chart.js - Time Series Area",
      func: timeSeries("line", true)
    },

    timeSeriesBar: {
      name: "Chart.js - Time Series Bar",
      func: timeSeries("bar")
    },

    bar: {
      name: "Chart.js - Bar Chart",
      func: function (app, label, axisLabel, data, elems, eventHandlers) {
        const color = Chart.helpers.color;
        const config = {
          type: 'bar',
          data: {
            labels: data.map((v) => v.label),
            datasets: [{
              label: axisLabel,
              backgroundColor: color(chartColors.blue).alpha(0.5).rgbString(),
              borderColor: chartColors.blueGrey,
              borderWidth: 1,
              data: data.map((v) => v.value)
            }]
          },
          options: {
            // Elements options apply to all of the options unless overridden in a dataset
            // In this case, we are setting the border of each horizontal bar to be 2px wide
            elements: {
              rectangle: {
                borderWidth: 2,
              }
            },
            responsive: true,
            maintainAspectRatio: false,
            legend: {
              display: false,
            },
            title: {
              display: true,
              text: label + " (" + data.length + " total)"
            },
            onClick: function(ev, elements) {
              if (
                  elements[0] !== undefined &&
                  elements[0]._model !== undefined &&
                  elements[0]._model.label !== undefined &&
                  eventHandlers !== undefined &&
                  eventHandlers.hasOwnProperty(elements[0]._model.label)
                ) {
                eventHandlers[elements[0]._model.label](app);
              }
            }
          }
        };

        const ctx = elems.canvas.getContext("2d");
        return {context: ctx, chart: new Chart(ctx, config)};
      }
    },

    categoryBarC3: {
      name: "C3.js - Category Bar Chart",
      func: c3CategoryChart('bar')
    },

    barC3: {
      name: "C3.js - Bar Chart",
      func: c3Chart('bar')
    },

    horizontalBar: {
      name: "Chart.js - Horizontal Bar Chart",
      func: function (app, label, axisLabel, data, elems, eventHandlers) {
        const color = Chart.helpers.color;
        const config = {
          type: 'horizontalBar',
          data: {
            labels: data.map((v) => v.label),
            datasets: [{
              label: axisLabel,
              backgroundColor: color(chartColors.blue).alpha(0.5).rgbString(),
              borderColor: chartColors.blueGrey,
              borderWidth: 1,
              data: data.map((v) => v.value)
            }]
          },
          options: {
            // Elements options apply to all of the options unless overridden in a dataset
            // In this case, we are setting the border of each horizontal bar to be 2px wide
            elements: {
              rectangle: {
                borderWidth: 2,
              }
            },
            responsive: true,
            maintainAspectRatio: false,
            legend: {
              display: false,
            },
            title: {
              display: true,
              text: label + " (" + data.length + " total)"
            },
            onClick: function(ev, elements) {
              if (
                  elements[0] !== undefined &&
                  elements[0]._model !== undefined &&
                  elements[0]._model.label !== undefined &&
                  eventHandlers !== undefined &&
                  eventHandlers.hasOwnProperty(elements[0]._model.label)
                ) {
                eventHandlers[elements[0]._model.label](app);
              }
            }
          }
        };

        const ctx = elems.canvas.getContext("2d");
        return {context: ctx, chart: new Chart(ctx, config)};
      }
    },

    categoryHorizontalBarC3: {
      name: "C3.js - Category Horizontal Bar Chart",
      func: c3CategoryChart('bar', true)
    },

    horizontalBarC3: {
      name: "C3.js - Horizontal Bar Chart",
      func: c3Chart('bar', true)
    },

    pie: {
      name: "Chart.js - Pie Chart",
      func: function (app, label, axisLabel, data, elems, eventHandlers) {
        const color = Chart.helpers.color;
        const chartColorsKeys = Object.keys(chartColors);
        const config = {
          type: 'pie',
          data: {
            labels: data.map((v) => v.label),
            datasets: [{
              label: axisLabel,
              backgroundColor: data.map((v, i) => color(chartColors[chartColorsKeys[i % chartColorsKeys.length]]).alpha(0.5).rgbString()),
              data: data.map((v) => v.value)
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            title: {
              display: true,
              text: label + " (" + data.length + " total)"
            },
            onClick: function(ev, elements) {
              if (
                  elements[0] !== undefined &&
                  elements[0]._index !== undefined &&
                  data[elements[0]._index] !== undefined &&
                  eventHandlers !== undefined &&
                  eventHandlers.hasOwnProperty(data[elements[0]._index].label)
                ) {
                eventHandlers[data[elements[0]._index].label](app);
              }
            }
          }
        };

        const ctx = elems.canvas.getContext("2d");
        return {context: ctx, chart: new Chart(ctx, config)};
      }
    },

    pieC3: {
      name: "C3.js - Pie Chart",
      func: c3Chart('pie')
    },

    rawDataColonSeparated: {
      name: "Raw Data (No Chart), Colon Separated",
      func: function (app, label, axisLabel, data, elems, eventHandlers) {
        const sanitizer = document.createElement("span");
        const sanitizeText = (text) => {
          sanitizer.innerText = text;
          return sanitizer.innerHTML;
        };
        elems.raw.innerHTML = data.map((v) => "<var>"+sanitizeText(v.label)+"</var>: "+sanitizeText(v.value)).join("\n");
        return {raw: elems.raw};
      }
    },

    rawDataColumns: {
      name: "Raw Data (No Chart), Columns",
      func: function (app, label, axisLabel, data, elems, eventHandlers) {
        const sanitizer = document.createElement("span");
        const sanitizeText = (text) => {
          sanitizer.innerText = text;
          return sanitizer.innerHTML;
        };
        const maxWidth = data.reduce((currentMaxWidth, currentElem) => currentElem.label.length > currentMaxWidth ? currentElem.label.length : currentMaxWidth, 0);
        elems.raw.innerHTML = data.map((v) => sanitizeText(v.label)+(Array(maxWidth - v.label.length + 1).join(" "))+" "+sanitizeText(v.value)).join("\n");
        return {raw: elems.raw};
      }
    }
  };

  const originalHash = window.location.hash.replace(/^#/, '');
  let currentHash = originalHash;

  export default {
    oncreate () {
      const updateFromHash = (hash) => {
        try {
          const state = JSON.parse(hash);
          this.set({selectors: []});
          this.set(state);
        } catch (e) {
          // ignore errors here.
        }
      };
      updateFromHash(originalHash);
      setInterval(() => {
        // Compare the current hash with the window's hash. If the window's
        // hash has been updated, update our state.
        const windowHash = window.location.hash.replace(/^#/, '');
        if (windowHash !== currentHash) {
          currentHash = windowHash;
          updateFromHash(currentHash);
        }
      }, 5);

      this.observe('options', (newVal, oldVal) => {
        if (oldVal !== undefined && newVal.class === oldVal.class) {
          return;
        }
        const __aggregateFunctions = this.get("__aggregateFunctions");
        const aggregateFunction = this.get("aggregateFunction");
        if (!__aggregateFunctions.hasOwnProperty(aggregateFunction)) {
          const __aggregateFunctionsKeys = this.get("__aggregateFunctionsKeys");
          this.set({aggregateFunction: __aggregateFunctionsKeys[0]});
        }
      });
    },

    data () {
      return {
        __supportedClasses: [IceCastAccessLogEntry],
        __showQueryEditor: false,
        __loading: false,
        __currentChart: null,
        __chartFunctions: chartFunctions,
        __chartFunctionsKeys: Object.keys(chartFunctions),
        chartHeight: 500,
        aggregateFunction: "totalListenersOverTime",
        chartFunction: "timeSeriesSteppedArea",
        options: {
          "class": IceCastAccessLogEntry.class
        },
        selectors: [
          {
            "type": "&",
            "strict": ["resource", "/stream"]
          },
          {
            "type": "&",
            "gte": ["timeEnd", null, "-1 week"],
            "lte": ["timeStart", null, "now"]
          },
          {
            "type": "&",
            "gte": ["duration", 300],
            "lte": ["duration", 86400]
          }
        ]
      }
    },

    computed: {
      __aggregateFunctions: (options) => Nymph.getEntityClass(options.class).aggregateFunctions,
      __aggregateFunctionsKeys: (options) => Object.keys(Nymph.getEntityClass(options.class).aggregateFunctions),
      query: (options, selectors) => [options, ...selectors],
      urlHashUpdate: (aggregateFunction, chartFunction, options, selectors, chartHeight) => {
        currentHash = JSON.stringify({aggregateFunction, chartFunction, options, selectors, chartHeight});
        window.location.hash = currentHash;
        return null;
      }
    },

    methods: {
      runQuery () {
        const __currentChart = this.get("__currentChart");
        const aggregateFunction = this.get("aggregateFunction");
        const chartFunction = this.get("chartFunction");

        if (__currentChart && __currentChart.chart) {
          __currentChart.chart.destroy();
        }
        if (__currentChart && __currentChart.context) {
          __currentChart.context.clearRect(0, 0, this.refs.chartcanvas.width, this.refs.chartcanvas.height);
        }
        if (__currentChart && __currentChart.raw) {
          __currentChart.raw.innerHTML = "";
        }

        this.set({
          __currentChart: null,
          __loading: true
        });
        const query = this.get("query");
        Nymph.getEntities(...query).then((entries) => {
          const aggFuncObj = this.get("__aggregateFunctions")[aggregateFunction];
          const chartFuncObj = chartFunctions[chartFunction];
          // Run the aggregator:
          const aggResults = aggFuncObj.func(entries);
          const data = aggResults.data;
          const eventHandlers = aggResults.eventHandlers;

          // Create the chart:
          this.set({
            __currentChart: chartFuncObj.func(this, aggFuncObj.name, aggFuncObj.axisLabel, data, {
              canvas: this.refs.chartcanvas,
              titlesvg: this.refs.titlesvg,
              svg: this.refs.chartsvg,
              raw: this.refs.rawelem
            }, eventHandlers),
            __loading: false
          });
        }, (err) => {
          alert("Error: "+err);
        });
      },

      toggleQueryEditor () {
        this.set({__showQueryEditor: !this.get("__showQueryEditor")});
      }
    },

    components: {
      QueryEditor
    }
  };
</script>

<style>
  .w-auto {
    width: auto;
  }

  .query-editor h2 {
    border-bottom: 1px solid #000;
    padding-bottom: .5em;
    margin-bottom: .5em;
  }

  .chart-container > .hidden {
    display: none;
  }
  .chart-canvas {
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
  }
  .loader,
  .loader:after {
    border-radius: 50%;
    width: 3em;
    height: 3em;
  }
  .loader {
    margin: 60px auto;
    font-size: 10px;
    position: relative;
    text-indent: -9999em;
    border-top: 1.1em solid rgba(0,0,0, 0.2);
    border-right: 1.1em solid rgba(0,0,0, 0.2);
    border-bottom: 1.1em solid rgba(0,0,0, 0.2);
    border-left: 1.1em solid #000000;
    -webkit-transform: translateZ(0);
    -ms-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-animation: load8 1.1s infinite linear;
    animation: load8 1.1s infinite linear;
  }
  @-webkit-keyframes load8 {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  @keyframes load8 {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
</style>
